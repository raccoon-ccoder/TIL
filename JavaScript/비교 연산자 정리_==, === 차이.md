## 비교 연산자 정리_==, === 차이
동등 비교 연산자(`==`)와 일치 비교 연산자(`===`)는 좌항, 우항을 비교하지만 비교하는 엄격성의 정도가 다르다.

### == (동등 비교 연산자)
- 좌항, 우항 비교할 때 먼저 `암묵적 타입 변환`을 통해 타입을 일치시킨 후 `같은 값`인지 비교한다. (값만 같다면 true)
- 편리한 경우도 있지만 결과를 예측하기 어렵고 실수하기 쉽다.
```js
// 동등 비교
5 == 5; // → true

// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다
5 == '5'; // → true

// 동등 비교. 결과를 예측하기 어렵다
'0' == ''; // → false
0 == ''; // → true
```

### === (일치 비교 연산자)
- 좌항, 우항의 `타입, 값`을 체크하여 모두 같은 경우에 한해 true를 반환한다. (즉, 암묵적 타입 변환을 하지 않고 값을 비교)
- 일치 비교 연산자에서 주의할 것은 `NaN`이다. NaN은 자신과 일치하지 않은 유일한 값으로 숫자가 NaN인지 조사하려면 함수 `Number.isNaN()`을 사용한다.
```js
// 일치 비교
5 === 5; // → true

5 === '5'; // → 타입이 다르게 false

// NaN은 자신과 일치하지 않는 유일한 값
NaN === NaN; // → false

// NaN(Not a Number) : 숫자가 아니라는 뜻으로 isNaN() 적용시 숫자가 아니라면 true, 숫자라면 false를 반환
Number.isNaN(NaN); // → true
Number.isNaN(10); // → false;
```

### Object.is()
- NaN 외에도 +0, -0은 ===, == 모두 동일하다고 평가하는 특이한 케이스가 있다. 
- 따라서 ES6에서 도입된 `Object.is()` 메서드는 `예측 가능한 정확한 비교 결과`를 반환한다. 그 외에는 일치 비교 연산자(===)와 동일하게 작동한다.
```js
-0 === +0; // → true
Object.is(+0,-0); // → false

Nan === NaN; // → false
Object.is(NaN,NaN); // → true
```

### 배열 or 객체
```js
const a = [1,2,3];
const b = [1,2,3];

console.log(a == b);  // false
console.log(a === b); // false

const a = {};
const b = {};

console.log(a == b);  // false
console.log(a === b); // false
```
- 배열 할당시, 각 변수는 각 메모리의 주소를 참조한다.
- 두 변수 a,b의 값과 데이터 타입이 같지만, 이와 상관 없이 참조하는 메모리의 주소가 다르기에 두 a,b는 같지 않으며 객체도 마찬가지다.




```js
const a = [1,2,3];
const b = [1,2,3];
const c = b;

console.log(b == c);  // true
console.log(b === c); // true

const a = {};
const b = {};
const c = b;

console.log(b == c);  // true
console.log(b === c); // true
```
- 새로운 변수 c에 변수 b를 할당하면, 변수 c도 b가 참조하는 같은 메모리의 주소를 참조하게 된다.
- 따라서 두 변수 b,c는 같으며 이때 b,c의 값과 데이터 타입이 같기에 ==와 ===의 결과값이 동일하며 객체도 마찬가지다.
