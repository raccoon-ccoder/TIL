## [자바스크립트 심화] 실행 컨텍스트 개념
자바스크립트의 필수 개념이라 할 수 있는 실행 컨텍스트에 대해, 어떤 원리인지 공부하면서 정리한 글이다.   
실행 컨텍스트의 Lexical Enviroment (Record, Outer)에 대해서만 정리해본다.   
![스크린샷 2022-02-09 오전 2 39 02](https://user-images.githubusercontent.com/77538818/153044320-0105d823-4980-4ea3-a49d-6bfd4c482002.png)

### 실행 컨텍스트는 언제 나타나고 없어지나?
![스크린샷 2022-02-09 오전 1 37 21](https://user-images.githubusercontent.com/77538818/153033398-adef6386-e28e-4bc0-8c2f-6b85c2c3579f.png)

<br/>

(1) 코드 실행
- 자바스크립트 엔진은 `콜 스택`(Call Stack)이라는 통에 `전역 실행 컨텍스트`를 담는다.
- 실행 컨텍스트 내부에는 `Record`, `Outer`가 담겨있다.

(2) 전역에서 함수 a를 호출
- `함수 a의 실행 컨텍스트`를 생성해 콜 스택에 담는다.
- 참고로 콜 스택에선 가장 `최근에 추가된 실행 컨텍스트`만 활성화된다. (위에서 내려다봤을 때 보이는 실행 컨텍스트 → `활성화된 실행 컨텍스트`)
- 즉, 현재 활성화된 실행 컨텍스트는 함수 a의 실행 컨텍스트

(3) 함수 a에서 함수 b가 호출된 경우
- 또 실행 컨텍스트를 담게 된다.

(4) 함수 b의 실행을 마치고 함수 b가 종료
- 함수 b의 실행 컨텍스트가 콜 스택에서 사라지며 함수 a의 실행 컨텍스트로 돌아온다.

(5) 함수 a가 종료
- 함수 a의 실행 컨텍스트가 사라진다.

(6) 전역에 있는 코드 마지막까지 실행
- 전역 컨텍스트도 사라지며 콜 스택은 비어지게 된다.

<br/>

### Record의 이해
`Enviroment Record`, 환경 레코드로 식별자와 식별자에 바인딩된 값을 기록해두는 객체로 호이스팅과 밀접한 연관이 있다.

<br/>

### 변수 호이스팅
- 선언 라인 전에도 에러 나지 않고 변수를 참조할 수 있는 현상. 
**Q) 어떻게 에러가 나지 않는 걸까?**
 → JS 엔진이 전체 코드를 스캔하면서 변수 같은 정보를 `실행 컨텍스트` 어딘가에 미리 기록한다.  
 여기서 어딘가는 `환경 레코드`를 의미하며 식별자와 식별자에 바인딩된 값을 기록해두는 객체다.   

<br/>

아래 코드를 살펴보자.

<br/>

```js
console.log(a); // (1) undefined
var a = "hi";   // (2)
console.log(a); // (3) hi
```

<br/>

JS 엔진은 소소코드를 2개의 과정으로 나누어 처리한다.   
#### 1. 생성 단계
1. create & push   
    1. JS는 코드 실행시 `전역 컨텍스트`를 생성하여 콜 스택에 넣는다.   
2. scan & declare   
    1. 전체 코드를 스캔하며 선언할 게 있다면 먼저 선언한다.   
    2. 선언 과정에서 먼저 생성해둔 실행 컨텍스트 안에 `환경 레코드`에 새로운 식별자 a를 기록한다. (var 키워드이므로 undefined로 초기화도 진행) → `{a : undefined}`   
#### 2. 실행 단계 
1.console.log(a);  // undefined 
  - a 출력을 위해 a에 바인딩된 값을 JS 엔진은 현재 활성화된 실행 컨텍스트 내에 환경 레코드를 보고 이미 기록된 a의 값을 참조해서 값을 출력한다.  
2. a = "hi"  
  - 선언은 생성 단계에서 했으므로 할당만 실행한다. → `{a : "h1"}`
3. console.log(a); // hi
  - JS 엔진은 환경 레코드를 참조해 a의 값을 "h1"로 결정하고 출력한다. (원래 consloe.log 실행 컨텍스트도 콜스택에 생성되어 올려지지만 생략)

### Outer
`Outer Enviroment Reference`, `외부 환경 참조`로 바깥 렉시컬 환경(정적 환경)을 가리킨다.

<br/>

```js
// (1) Global
let lamp = false;

function goto2F() {
    let lamp = true;

    console.log(lamp); // true

    function goto3F() {
        let pet = 'puppy';

        console.log(pet); // puppy
        console.log(lamp); // true ? false ?
    };

    goto3F(); // (3)
}

goto2F(); // (2)
```
![스크린샷 2022-02-09 오전 2 53 44](https://user-images.githubusercontent.com/77538818/153047059-210b501a-a647-412f-9e7d-3c82285651d1.png)

<br/>

위 코드를 실행했을 때의 실행 컨텍스트를 그림으로 나타냈으며 환경 레코드를 편의상 그림으로 표현했다.
1. (생성단계) 콜스택에 `전역 실행 컨텍스트`가 생성되고 환경 레코드에 `lamp`, `goto2F` 함수가 기록된다.
2. (실행단계) 코드를 순차적으로 실행하여 `goto2F 함수 실행 컨텍스트`가 콜스택에 추가되며 해당 컨텍스트의 환경 레코드에는 `lamp`와 `goto3F` 함수가 기록된다.
  - 이때 함수의 실행 컨텍스트를 새로 생성하고, **JS 엔진은 새로 생성된 실행 컨텍스트에 바깥 렉시컬 환경으로 돌아갈 수 있는 `outer`를 만든다**
3. goto3F 함수가 실행되어 `goto3F 함수 실행 컨텍스트`가 추가되고 내부 환경 레코드에는 `pet`이 기록된다.
  - 이때 goto3F 내부의  console.log(lamp)는 어떤 값이 출력될까?
    - 현재 활성화된 실행 컨텍스트(goto3F)에는 lamp가 없기에 `outer`를 타면서 2층에 있는 lamp를 찾게 된다.
    - 2층에 있는 lamp를 찾았기에 true가 출력되며 전역 컨텍스트에 있는 lamp(1층)의 값은 무시하게 된다.
    - 이렇게 동일한 식별자로 인해 상위 스코프에서 선언된 식별자의 값이 가려지는 현상을 `변수 섀도잉`이라 한다.

즉, 현재 활성화된 실행 컨텍스트는 1개지만 이전 렉시컬 환경을 가리키는 outer로 타고타고 갈 수 있는 것을 `스코프 체인`이라 하며 식별자를 결정할 때 활용하는 스코프들의 연결리스트다.

***

### 정리
- 호이스팅 - 선언 라인 전에도 에러 없이 변수를 참조할 수 있는 현상
  - Why? - JS 엔진은 소스 코드 실행 전 전체 코드를 스캔하며 콜 스택에 있는 전역 실행 컨텍스트의 `환경 레코드`에 식별자를 기록하기 때문
- 변수 호이스팅
  - var - 선언 & undefined 초기화가 동시에 진행 → 선언 라인 전에 변수 호출하면 undefined로 출력
  - let, const - 호이스팅되지만 선언만 되고 초기화는 값할당시 진행 → 선언 라인 전에 변수 호출하면 Reference Error
- 함수 호이스팅
  - 함수 표현식 (변수 호이스팅과 동일) 
    - var - 변수가 선언되고 초기화가 되지만 함수가 아닌 undefined로 초기화 → 선언 라인 전에 함수 호출시 (study();) type error 발생
    - let, const - 선언만 된 상태 → 선언 라인 전에 함수 호출시 Reference Error
  - 함수 선언문
    - 선언과 동시에 생성을 마치고 온전하게 환경 레코드에 저장 → 선언 라인 전에 함수 호출시 정상적으로 출력
- 생성 단계
  - 콜 스택에 실행 컨텍스트를 생성
  - 선언문만 실행하여 환경 레코드에 식별자 기록
- 실행 단계
  - 선언문과 나머지 코드 순차적 실행
  - 환경 레코드 참조 or update
- 선언과 초기화란
  - 선언 - 변수명(식별자)를 실행 컨텍스트의 환경 레코드에 등록하는 과정으로 JS 엔진이 변수의 존재를 알리는 셈이다.
  - 초기화 - 값을 저장하기 위한 메모리 공간 확보 및 암묵적으로 undefined를 할당해 초기화한다.   
- ES3까지는 동적 스코프, 즉 함수가 호출될 때마다 동적으로 그에 맞는 스코프 생성 및 스코프 체인을 연결했기에 식별자 결정에 실행 컨텍스트의 역할이 크지 않았다.
- ES5 이후 식별자 결정 메커니즘이 변경되면서 스코프가 호출되는 위치와 상관없이 어다에 선언되었느냐에 따라 정적으로 결정되는 정적 스코프로 바뀌면서 JS 엔진은 더 빠르고 효울적으로 식별자를 결정할 수 있게 되었다.
- `실행 컨텍스트` - 코드를 실행하는데 필요한 환경(코드 실행에 영향을 주는 조건이나 상태)을 제공하는 객체로써 식별자 결정을 더욱 효율적으로 하기 위한 수단
- `환경 레코드` - 환경 레코드로 식별자와 식별자에 바인딩된 값을 기록해두는 객체
- `outer` - Outer Enviroment Reference, 외부 환경 참조로 바깥 렉시컬 환경(정적 환경)을 가리킴
- 스코프 체인 - 식별자를 결정할 때 활용하는 스코프들의 연결리스트

### 문제
```js
var x = 1;

function foo() {
    var x = 10;
    bar();
}

function bar() {
    console.log(x);
}

foo();  // ?
bar();  // ?
```

<br/>

아래와 같은 코드가 있을 때 콘솔창에는 어떤 값이 출력될까?   
<details>
<summary>정답</summary>
<div markdown="1">

- 둘 다 1로 출력되는데 bar 함수의 실행 컨텍스트에는 x가 없기에 outer를 통해 외부 렉시컬 환경에서 찾게 된다.
- 아래의 그림처럼 foo, bar 함수 모두 전역에서 정의된 전역 함수기 때문에 어디서 호출되어도 상위 스코프는 항상 전역이다.  
- 따라서 그림처럼 bar 함수의 outer도 외부 렉시컬 환경인 전역을 참조하게 되기에 전역 실행 컨텍스트에 있는 x=1, 즉 1을 출력하게 된다.
<img width="544" alt="스크린샷 2022-02-09 오전 3 27 34" src="https://user-images.githubusercontent.com/77538818/153052181-ee76636f-7110-4842-ae86-306fe1a62669.png">


</div>
</details>
