## 7. [드림코딩 JS - 7. Callback, Promise]
자바스크립트sms 동기적이어서 코드가 순차적으로 실행되며 비동기 처리를 위한 `Callback`, `Promise`, `await/async`가 있다.   
비동기 처리를 하는 간단한 이유는 원하는 때에 동작이 시작할 수 있도록 하기 위함이 있다.

### Callback
```js
console.log('1');
setTimeout(() => console.log('2'), 1000);
console.log('3');

// 1
// 3
// 2 (setTimeout() 호출 후 1초 뒤에)
```
- 위 코드에서 setTime() 메서드의 매개변수인 consloe.log()는 바로 실행되는 것이 아니라 1초 뒤애 실행하는 콜백함수이다.

#### Synchronous callback
```js
// 즉각적으로 실행되는 콜백 함수
function printImmediately(print) {
    print();
}

printImmediately(() => console.log('hello'));   // hello
```

#### Asynchronous callback
```js
// 언제 실행되는지 예측할 수 없는 콜백 함수
function printWithDelay(print, timeout) {
    setTimeout(print, timeout);
}

printWithDelay(() => console.log('async callback'), 2000);  // async callback (2초 후 실행)
```
#### Callback Hell
```js
class UserStorage {
    loginUser(id, password, onSuccess, onError) {
        setTimeout(() => {
            if (
                (id === 'raccoon' && password === '123') ||
                (id === 'cat' && password === '456')
            ) {
                onSuccess(id);
            } else {
                onError(new Error('not found'));
            }
        }, 2000);
    }

    getRoles(user, onSuccess, onError) {
        setTimeout(() => {
            if (user === 'raccoon') {
                onSuccess({ name: 'raccoon', role: 'admin'});
            } else {
                onError(new Error('no access'));
            }
        }, 1000);
    }
}

const userStorage = new UserStorage();
const id = prompt('enter your id');
const password = prompt('enter your password');
userStorage.loginUser(
    id,
    password,
    user => {
        userStorage.getRoles(
            user, 
            userWithRole => {
                alert(`hello, ${userWithRole.name}, you have a ${userWithRole.role} role`);
            },
            error => {
                console.log(error);
            }
        );
    },
    error => {
        console.log(error);
    }
);
```
- 사용자에게 id, password를 입력 받아 가입된 사용자인지, 권한이 있는지 확인하는 코드로 setTimeout()을 이용해 시간차를 둬서 서버와 통신한다고 가정한다.  
- 위 코드처럼 꼬리를 무는 비동기 동작이 많아지면 가독성이 떨어지며 깊은 중첩 코드로 인한 `콜백 지옥 패턴`을 맞이하게 된다.

### Promise
```js
let promise = new Promise(function(resolve, reject) {
  // executor (제작 코드, '가수')
});
```
- 콜백 함수 대신 유용하게 사용할 수 있는 비동기 처리를 위한 `JavaScript 객체`다.
- new Promise 생성자가 반환하는 promise 객체는 `state`, `result` 라는 내부 프로퍼티를 갖는다.
- promise에서 중요한 포인트는 state, producer & consuemr 이다.
- `state` - operation을 수행 중인지, 수행 완료 했는지, 수행 실패했는지에 대한 상태
  - `pending` - promise가 만들어져서 우리가 지정한 operation이 수행 중일 경우
  - `fulfilled` - operation이 성공적으로 수행된 경우
  - `rejected` - operation이 실패한 경우
- `result` - 처음엔 undefined, resolve(value)가 호출되면 `value`, reject(error)가 호출되면 `error`로 변한다.
- `producer & consumer` - 간단하게 데이터를 제공하는 사람, 제공된 데이터를 사용하는 사람의 차이

#### Producer
- Promise 객체를 만드는 순간 내부의 `executor√라는 실행 함수가 바로 실행된다.
- 따라서 버튼 클릭시 처리해야 하는 일인 경우 promise 객체를 생성하면 불필요한 네트워크 통신이 이뤄질 수 있다.
```js
const promise = new Promise((resolve, reject) => {
    // doing some heavy work (network, read files..)
    console.log('doing something...');
    setTimeout(() => {
        // resolve('raccoon');  // (operation에 성공했을 경우) raccoon
        reject(new Error('no network'));    // (operation에 실패했을 경우) Uncaught (in promise) Error: no network
    }, 2000);
});
```

#### Consumer
- Promise 객체는 executor 실행 함수와 결과나 에러를 받을 소비 함수를 이어주는 역할을 한다.
- 소비 함수는 `then()`, `catch()`, `finally()` 메서드를 사용한다.
```js
promise
    .then((value) => {
        console.log(value); // raccoon
    })
    .catch(error => {
        console.log(error); // Error: no network
    })
    .finally(() => {    // 성공 실패 여부와 상관없이 무조건 실행하고 싶을 경우
        console.log('finally'); // finally
    });
// then 호출시 Promise 객체가 return 되기에 그 객체에 catch를 적용함 (체이닝)
```

#### Consumer - then()
```js
promise.then(
  function(result) { /* 결과(result)를 다룹니다 */ },
  function(error) { /* 에러(error)를 다룹니다 */ }
);
```
- 첫번째 인수는 promise가 `이행`되었을 때 실행하는 함수로 여기서 `실행 결과`를 받는다.
- 두번째 인수는 promise가 `거부`되었을 때 실행되는 함수고, 여기서 `에러`를 받는다.
- 작업이 성공적으로 처리된 경우만 다루고 싶다면 then()에 인수를 하나만 전달한다.

### Promise chaining
- 비동기 작업이 여러 개 있을 경우 `Promise chaining`을 이용할 수 있다.
```js
const fetchNumber = new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000);
});

fetchNumber
    .then(num => num * 2)
    .then(num => num * 3)
    .then(num => {
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(num - 1), 1000);
        });
    })
    .then(num => console.log(num)); // 5
```
- promise chaining이 가능한 이유는 fetchNumber 는 promise 객체고 promise.then()을 하면 promise가 반환되기 때문이다. 거기에는 당연히 then()을 호출할 수 있다.  
**Q) then()은 promise에만 사용할 수 있는 메서드 아닌가?**
→ 핸들러가 값을 반환하면 `result`가 되고 다음 then()은 이 값을 이용해 호출된다. 

### Promise Error Handling
- promise가 거부되면 제어 흐름이 제일 가까운 rejection 핸들러로 넘어가기에 `promise chaining`을 사용하여 에러를 쉽게 처리할 수 있다.
- 아래 에러 발생시 코드처럼 `catch()`는 첫번째 핸들러일 필요가 없으며 여러 개의 `then()` 뒤에 올 수도 있다.
```js
// 정상 코드
const getHen = () =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve('🐓'), 1000);
    });
const getEgg = hen =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve(`${hen} => 🥚`), 1000);
    });
const cook = egg =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve(`${egg} => 🍳`), 1000);
    });

getHen()
    .then(getEgg)   // 콜백함수 전달시 받아오는 value를 다른 함수에 바로 넣어주는 경우 value 생략 가능
    .then(egg => cook(egg))
    .then(meal => console.log(meal))   // 🐓 => 🥚 => 🍳
    .catch(console.log);
```
```js
// 에러가 생겼을 경우
const getHen = () =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve('🐓'), 1000);
    });
const getEgg = hen =>
    new Promise((resolve, reject) => {
        setTimeout(() => reject(new Error(`${hen} => 🥚`)), 1000);   // 에러 발생 !!! 
    });
const cook = egg =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve(`${egg} => 🍳`), 1000);
    });

getHen()
    .then(getEgg)   // 콜백함수 전달시 받아오는 value를 다른 함수에 바로 넣어주는 경우 value 생략 가능
    .catch(error => {   // 계란을 받아오는 것에 문제가 생길 경우 빵으로 대체하는 코드
        return '🍞';
    })
    .then(egg => cook(egg))
    .then(meal => console.log(meal))   // 🍞 => 🍳
    .catch(console.log);
```

#### 만약 catch()가 없다면 ?
```js
new Promise(function() {
  noSuchFunction(); // 에러 (존재하지 않는 함수)
})
  .then(() => {
    // 성공상태의 프라미스를 처리하는 핸들러. 한 개 혹은 여러 개가 있을 수 있음
  }); // 끝에 .catch가 없음!
```
- 에러 발생시 promise는 거부 상태가 되고, 예외 처리를 해줄 핸들러가 없기에 에러가 '갇혀버린다'.
- 자바스크립트 엔진은 promise 거부를 추적하다 위와 같은 상황 발생시, 전역 에러를 생성하며 브라우저 환경에선 `unhandledrejection` 이벤트로 잡을 수 있다.
```js
window.addEventListener('unhandledrejection', function(event) {
  // 이벤트엔 두 개의 특별 프로퍼티가 있습니다.
  alert(event.promise); // [object Promise] - 에러를 생성하는 프라미스
  alert(event.reason); // Error: 에러 발생! - 처리하지 못한 에러 객체
});

new Promise(function() {
  throw new Error("에러 발생!");
}); // 에러 처리 핸들러, catch가 없음
```
- `unhandledrejection` 핸들러는 에러 정보가 담긴 `event` 객체를 받기에 이 핸들러 안에서 원하는 작업을 할 수 있다.
- 대개 이런 에러는 회복할 수 없기에 개발자로서 할 수 있는 최선의 방법은 사용자에게 문제 상황을 알리고 가능하면 서버에 에러 정보를 보내는 것이다.
    
### Callback hell to Promise
```js
'use strict';
class UserStorage {
    loginUser(id, password) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (
                    (id === 'raccoon' && password === '123') ||
                    (id === 'cat' && password === '456')
                ) {
                    resolve(id);
                } else {
                    reject(new Error('not found'));
                }
            })
        }, 2000);
    }

    getRoles(user) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (user === 'raccoon') {
                    resolve({ name: 'raccoon', role: 'admin'});
                } else {
                    reject(new Error('no access'));
                }
            }, 2000);
        })
    }
}

const userStorage = new UserStorage();
const id = prompt('enter your id');
const password = prompt('enter your password');
userStorage
    .loginUser(id, password)
    .then(userStorage.getRoles)
    .then(console.log)
    .catch(console.log);
```

